#+author: death-of-rats
#+title: RSA-AES challenge
#+date: \today
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADERL \usepackage{unicode-math}

Flaga i podstawowe dane do szyfrowania RSA:

#+BEGIN_SRC jupyter-python :display plain
e = 0x10001
M = b"actf{the_letters_in_rsa_and_aes_form_aries_if_you_throw_in_the_letter_i_because_that_represents_yourself_or_something_anyway_aries_is_a_zodiac_sign_which_means_that_the_two_cryptosystems_are_mutually_compatble_i_think}"
N=23100028007870325783185834854225420810294934833542002516071573559725954624158254241681531108254811992152391330196659130138562293154330788367194811021643366683965159626531673375163335903802878418922588761148831560375220232790576797320885239420328061465883494343484169205143945161452020074030236272423633651542587783663231883652666578166091932882621607201276775089510876377814861854076054384741632988719559243513691909274012936697373832908759138215954796841768884521430353724961486282715856244282784138169211412655478210437529819247752450082552313348995988653427767077759405830302351589964380906097867393519224077222417
d=6939842401192591121734987906752587245890061674132299121701225442382842067764039668652328699672383437043020475460305195741308771990106640404072487819172928981195203135431620566757570847154658791067135360456831173111795034307546371705310122204965732368002504236215569944917819495610553172064350244407722705726779950842939416856688350900937391297793156361970425401834222208765308134550815138084431002958641575681048362621060848707903209002223186224150428170316897580755806313761372979684359108114747048822425236542115249545967974464243439666000827897452100022638567865824970888498575221273968847274554834303990380428245

print(f"{M=}")
#+END_SRC

#+RESULTS:
: M=b'actf{the_letters_in_rsa_and_aes_form_aries_if_you_throw_in_the_letter_i_because_that_represents_yourself_or_something_anyway_aries_is_a_zodiac_sign_which_means_that_the_two_cryptosystems_are_mutually_compatble_i_think}'

Zaszyfrowana flaga:

#+BEGIN_SRC jupyter-python
from Crypto.Util.number import bytes_to_long, long_to_bytes
m = bytes_to_long(M)
c = pow(m, e, N)
print(f"{c= }")
#+END_SRC

#+RESULTS:
: c= 19321714535721721163928531416665898956263658672469322997298398688551143250210263206561558407170600834764379951742679808694521538906634332095633471740584661865539177702935568600523278386312997112413716020209076817610256138835424559365914906051120298439855383497706245008988286580253063780690272786674425098266898117909220704997415276432346565970370473199577838142496174986469468104273672407706458027420762691329572365844559257927814899985074239685742963871494430855238689556053775329562132610781930166806489252817286592933199369118061874369027601185173542046280079969164137593911770652945686501676794296634265460065476


### RSA Oracle.

Akurat nie do zastosowania tutaj.


#+BEGIN_SRC jupyter-python
k = 0
kN = []
flag_size = m.bit_length()
prev_size = flag_size
print(f"{flag_size=}")
for i in range(flag_size):
    dm = pow(c*pow(2**(i+1),-e,N), d, N)
    new_len = dm.bit_length()
    if prev_size != new_len+1:
        k |= 1 << i
    kN.append(k)
    prev_size = new_len

f = 0
for i, ki in enumerate(kN):
    f +=  ((f+ki*N) % 2**(i+1))

print(long_to_bytes(f))

#+END_SRC

#+RESULTS:
: flag_size=1743
: b'actf{the_letters_in_rsa_and_aes_form_aries_if_you_throw_in_the_letter_i_because_that_represents_yourself_or_something_anyway_aries_is_a_zodiac_sign_which_means_that_the_two_cryptosystems_are_mutually_compatble_i_think}'

## Rozwiązanie

Implementacja zadania:

#+BEGIN_SRC jupyter-python

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

k = long_to_bytes(0x54346545b56c9637c6528a6d0a0232872300436581c94a32b60a437e67113a41)
iv= long_to_bytes(0x54346545b56ac637c6538a6d0a023211)

aes = AES.new(k, AES.MODE_CBC, iv)

def encrypt(inp: int):
    tmp = pow(inp, d, N)
    msg = pad(long_to_bytes(tmp),16)
    return aes.encrypt(msg)

#+END_SRC

#+RESULTS:

Liczenie długości flagi - akurat również nie niezbędne tutaj.

#+BEGIN_SRC jupyter-python
def zero_iv():
    zero_msg_1 = 0x414141414141414141414141414141
    zero_msg_2 = bytes_to_long(encrypt(pow(zero_msg_1, e, N)))
    return encrypt(pow(zero_msg_2, e, N))[-16:]

max_msg = encrypt(pow(N-1,e,N))
max_length = len(max_msg)
print(f"{max_length}")

def calculate_flag_size():
    global max_length, c, e, N
    n_len = N.bit_length()//8
    for i in range(n_len):
        tmsg = encrypt(c*pow(2**(8*i),e,N))
        if len(tmsg) >= max_length:
            return (n_len - i, i)

flag_size, off = calculate_flag_size()
print(f"{flag_size=}")

search_size = 15 + 16*( (flag_size-15)//16+1 )
print(f"{search_size=}")
#+END_SRC

#+RESULTS:
: 272
: flag_size=218
: search_size=223


Implementacja oracle i wyznaczenie B dla metody ataku Mangera:

#+BEGIN_SRC jupyter-python
from math import ceil

#B = 2**(8*(ceil(N.bit_length()/8) - 1))
k = N.bit_length()//8
B = 2**(8*(k-1))
print(f"2B > N ? {2*B > N}")
B_len = len(encrypt(pow(B,e,N)))
print(f"{B_len=}")
print(len(encrypt(c)))

def testOracle(inp: int) -> bool:
    global B_len, c, N, e
    r = encrypt((pow(inp,e,N)*c) % N)
    return len(r) >= B_len

#+END_SRC

#+RESULTS:
: 2B > N ? False
: B_len=272
: 224

#### 1 krok

Wyznaczenie przesunięcia bitowego, które wyniesie flagę ponad wartość B:

#+BEGIN_SRC jupyter-python
# step 1 find i - bit offset so message*2^i is larger than B
f1i=1
count1 = 0

for i in range(1,N.bit_length(),1):
    count1 += 1
    if testOracle(2**i):
        f1i = 2**i
        break

f1i_2 = f1i // 2
print(f"{f1i_2=}")
print(f"{count1=}")

#+END_SRC

#+RESULTS:
: f1i_2=254629497041810760783555711051172270131433549208242031329517556169297662470417088272924672
: count1=298

#### krok 2

Wyznaczenie $$ f_{2,j} $$:

#+BEGIN_SRC jupyter-python

# step 2 find min f2j
print(f"{ceil(N/B)=}")
#+END_SRC

#+RESULTS:
: ceil(N/B)=183

#+BEGIN_SRC jupyter-python

# step 2 find min f2j
f2j = f1i_2 * (N+B) // B
for j in range(ceil(N/B)):
    if not testOracle(f2j):
        break
    f2j = f2j + f1i_2

print(f"{f2j=}")
#+END_SRC

#+RESULTS:
: f2j=61362518208967939725116188233178560427534331657637840206388226072257535858995346388868760786


#+BEGIN_SRC jupyter-python
# step 3 - binary search

m_min = N // f2j
m_max = (N+B) // f2j
print(f"{m_min=}")
print(f"{m_max=}")
BB = 2*B

dtc = N
for _ in range(5000):
    diff = m_max-m_min
    if diff > dtc:
        print(f"idziemy nie w ta stronę... :( {diff - dtc}")
        break
    dtc = diff

    f_mid = BB // diff
    ik = (f_mid * m_min) // N
    ikN = ik * N
    f3 = (ikN // m_min) + (0 if ikN % m_min == 0 else 1)
    ikNB = ikN + B          # 2B/diff  + diff / 2
    if testOracle(f3):
        m_min = ikNB // f3
        m_min += 0 if ikNB % f3 == 0 else 1
    else:
        m_max = ikNB // f3
    if m_min == m_max:
        break

print("")
print(f"{m_max-m_min}")
print(f"{dtc}")

print(long_to_bytes(m_min))
print(long_to_bytes(m_max))

#+END_SRC
#+RESULTS:
: m_min=376451760490075993747221371640229754002259338873712486587904450299275810357159351242236922469790894977528468662419767064061762214711533334100897796783610884898507451809141453012634045009285775903855076863090939418998409484888443757114735209470648304651996830289162821606835895714363587757934755869110601656873567300539233212657543215191323486513840175088051723812578248242768576449325158337927516465659606814533243681853181655516241195925696090526718940020002442735838766920139526357055658265878237555232902161413065223404223
: m_max=378509014798580061783179475805160219980460243502417420076577867225355921593233525229146672013044670635847282101795767563744269816899501017693047432103596565454890687587240207746091699510334122978954247156404225322006422923233782317260970342905460001604636664414597446907333514221203368894678039589063760339121530324617872022393277433673095669419734485819232810574199719709324493173478462180922354765017610015041793611440169235556032169870517205426502808729114281124438411649205488105102987794494097371377262420185667279412158
:
: 0
: 1
: b'actf{the_letters_in_rsa_and_aes_form_aries_if_you_throw_in_the_letter_i_because_that_represents_yourself_or_something_anyway_aries_is_a_zodiac_sign_which_means_that_the_two_cryptosystems_are_mutually_compatble_i_think}'
: b'actf{the_letters_in_rsa_and_aes_form_aries_if_you_throw_in_the_letter_i_because_that_represents_yourself_or_something_anyway_aries_is_a_zodiac_sign_which_means_that_the_two_cryptosystems_are_mutually_compatble_i_think}'
